<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>恶魔岛</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.1.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url()">
        </div>
    </section>
    <section class='menu'>
        <div>恶魔岛</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1></h1>
    </header>

    <section>
      <h2 id="Step0-导入需要的库"><a href="#Step0-导入需要的库" class="headerlink" title="Step0:导入需要的库"></a>Step0:导入需要的库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个显示结果的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cvshow</span>(<span class="params">name,img</span>):</span><br><span class="line">    cv2.imshow(name,img)</span><br><span class="line">    cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv2.destroyAllWindows()    </span><br></pre></td></tr></table></figure>

<h3 id="数据读取-图像"><a href="#数据读取-图像" class="headerlink" title="数据读取-图像"></a>数据读取-图像</h3><p><strong>cv2.imread(path,type)</strong><br> type的类型</p>
<ul>
<li>cv2.IMREAD_GRAYSCALE:读取灰度图像</li>
<li>cv2,IMREAD_COLOR:读取彩色图像</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\colors01.png&quot;</span>,cv2.IMREAD_COLOR)</span><br><span class="line">img2 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\colors01.png&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img1,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;COLOR&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(img2,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;GRAY&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;GRAY&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b29d69d0&gt;,
 Text(0.5, 1.0, &#39;GRAY&#39;))
</code></pre>
<p><img src="/.com//output_5_1.png"></p>
<h3 id="数据读取-视频"><a href="#数据读取-视频" class="headerlink" title="数据读取-视频"></a>数据读取-视频</h3><p><strong>cv2.VideoCapture(path)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vc = cv2.VideoCapture(<span class="string">&quot;D:\programing\Python\CV\coca_colaAD.mp4&quot;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vc.isOpened():</span><br><span class="line">    <span class="built_in">open</span>,frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">open</span> = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><strong>ROI:感兴趣的区域 在图像上直接截图即可</strong></p>
<p><strong>色彩类型转化：cv2.cvtColor(frame,cv2.COLOR_xxxx)</strong></p>
<blockquote>
<p>这里的xxxx有很多，比如BGR2GRAY、BGR2HSV等。</p>
</blockquote>
<p><strong>提取色彩通道：在图像的第三个维度将不需要保留的色彩信息置零</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">open</span>:</span><br><span class="line">    ret,frame  =vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#转化为灰度</span></span><br><span class="line">        gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment">#设置ROI</span></span><br><span class="line">        roi = gray[<span class="number">0</span>:,<span class="number">500</span>:<span class="number">1000</span>]</span><br><span class="line">        <span class="comment">#选择保留色彩通道</span></span><br><span class="line">        frame[:,:,<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">        frame[:,:,<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">&quot;Show&quot;</span>,frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">3</span>)&amp;<span class="number">0xFF</span> == <span class="string">&quot;q&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">vc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h2 id="简单处理"><a href="#简单处理" class="headerlink" title="简单处理"></a>简单处理</h2><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p><strong>用copyMakeBorder(img,top_size,bottom_size,left_size,right_size,borderType)函数</strong><br>    <em>borderType</em>  </p>
<blockquote>
<p>BORDER_REPLICATA：复制最边缘的像素<br>BORDER_REFLECT:对ROI中像素的两边进行复制<br>BORDER_REFLECT_101:以最边缘的像素为轴反射<br>BORDER_WRAP:外包装法<br>BORDER_CONSTANT:常数法，填充常数值  </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top_size,bottom_size,left_size,right_size = (<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)<span class="comment">#上下左右的大小</span></span><br><span class="line"></span><br><span class="line">replicate = cv2.copyMakeBorder(img1,top_size,bottom_size,left_size,right_size,borderType = cv2.BORDER_REPLICATE)</span><br><span class="line">reflect = cv2.copyMakeBorder(img1,top_size,bottom_size,left_size,right_size,borderType = cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img1,top_size,bottom_size,left_size,right_size,borderType = cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img1,top_size,bottom_size,left_size,right_size,borderType = cv2.BORDER_WRAP)</span><br><span class="line">constant = cv2.copyMakeBorder(img1,top_size,bottom_size,left_size,right_size,borderType = cv2.BORDER_CONSTANT)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">231</span>),plt.imshow(img1,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;orignal&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>),plt.imshow(replicate,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;replicate&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>),plt.imshow(reflect,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;reflect&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>),plt.imshow(reflect101,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;reflet101&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>),plt.imshow(wrap,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;wrap&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>),plt.imshow(constant,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;constant&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;constant&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b31e37f0&gt;,
 Text(0.5, 1.0, &#39;constant&#39;))
</code></pre>
<p><img src="/.com//output_13_1.png"></p>
<h3 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h3><p><strong>直接用numpy进行矩阵的数值运算，大于255的部分会进行取余数操作</strong><br><strong>使用cv2.add()进行数值计算，当结果大于255时，保留255，而非取余数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img3 = img1+<span class="number">200</span></span><br><span class="line">img4 = cv2.add(img1,<span class="number">200</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img4[<span class="number">0</span>:<span class="number">10</span>,<span class="number">0</span>:<span class="number">10</span>,:]</span><br></pre></td></tr></table></figure>




<pre><code>array([[[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]],

       [[255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255],
        [255, 242, 255]]], dtype=uint8)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(img3,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;numpy&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(img1,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;orignal&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(img4,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;cv2.add&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;cv2.add&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b97d45b0&gt;,
 Text(0.5, 1.0, &#39;cv2.add&#39;))
</code></pre>
<p><img src="/.com//output_17_1.png"></p>
<h3 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img01 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\wallhaven-p2j1w9.jpg&quot;</span>)</span><br><span class="line">img02 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\yeeee.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>img01+img02</p>
<p>由于两张图片的大小不同，很明显上面的语句会报错<br>因此我们需要对其中一张图片进行resize操作，使得图片的大小一致，才能直接数值计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img01 = cv2.resize(img01,(<span class="number">4368</span>,<span class="number">2912</span>))</span><br><span class="line">img01.shape</span><br></pre></td></tr></table></figure>




<pre><code>(2912, 4368, 3)
</code></pre>
<p><strong>resize还有操作</strong><br>cv2.resize(img,(0,0),fx &#x3D; x,fy &#x3D; y)<br>这里的x,y分别是图像水平和竖直拉伸的倍数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = cv2.addWeighted(img01,<span class="number">0.3</span>,img02,<span class="number">0.7</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(res)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b9a17fa0&gt;
</code></pre>
<p><img src="/.com//output_25_1.png"></p>
<h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p><strong>ret,dst&#x3D;cv2.threshold(src,thresh,maxval,type)</strong>  </p>
<ul>
<li>src:输入图，通常只能输入灰度图像  </li>
<li>dst:输出图  </li>
<li>thresh:阈值  </li>
<li>maxval:当像素超过阈值时赋予该像素点的值  </li>
<li>type:二值化的操作类型，有以下五种：<br>cv2.THRESH_BINARAY:超过阈值时取最大值，否则为0<br>cv2.THRESH_BINARY_INV:上一个类型的反转<br>cv2.THRESH_TRUNC:大于阈值的部分设为阈值，其余不变<br>cv2.THRESH_TOZERO:大于阈值的部分不变，其余为0<br>cv2.THRESHH_TOZERO_INV:上一个类型的反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ret,thresh1 = cv2.threshold(img2,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">ret,thresh2 = cv2.threshold(img2,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br><span class="line">ret,thresh3 = cv2.threshold(img2,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span><br><span class="line">ret,thresh4 = cv2.threshold(img2,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span><br><span class="line">ret,thresh5 = cv2.threshold(img2,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span><br><span class="line">title = [<span class="string">&#x27;orignal&#x27;</span>,<span class="string">&#x27;binray&#x27;</span>,<span class="string">&#x27;binray inv&#x27;</span>,<span class="string">&#x27;trunc&#x27;</span>,<span class="string">&#x27;tozero&#x27;</span>,<span class="string">&#x27;tozro inv&#x27;</span>]</span><br><span class="line">imgs = [img1,thresh1,thresh2,thresh3,thresh4,thresh5]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(imgs[i],<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(title[i])</span><br><span class="line">    plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/.com//output_27_0.png"></p>
<h3 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img11 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\stars.jpg&quot;</span>)</span><br><span class="line">plt.imshow(img11,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3bad73460&gt;
</code></pre>
<p><img src="/.com//output_29_1.png"></p>
<h3 id="滤波方法"><a href="#滤波方法" class="headerlink" title="滤波方法"></a>滤波方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#均值滤波</span></span><br><span class="line">blur = cv2.blur(img11,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#方框滤波</span></span><br><span class="line">box = cv2.boxFilter(img11,-<span class="number">1</span>,(<span class="number">3</span>,<span class="number">3</span>),normalize = <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#高斯滤波</span></span><br><span class="line">guassian = cv2.GaussianBlur(img11,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">1</span>)</span><br><span class="line"><span class="comment">#中值滤波</span></span><br><span class="line">mid = cv2.medianBlur(img11,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">221</span>),plt.imshow(blur,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;blur&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>),plt.imshow(box,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;box&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>),plt.imshow(guassian,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;Gaussian&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>),plt.imshow(mid,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;mid&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;mid&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b9a9a940&gt;,
 Text(0.5, 1.0, &#39;mid&#39;))
</code></pre>
<p><img src="/.com//output_31_1.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = np.hstack((blur,box,guassian,mid))</span><br></pre></td></tr></table></figure>

<h2 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img21 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\yuan.jpg&quot;</span>)</span><br><span class="line">plt.imshow(img21,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b9a9b5b0&gt;
</code></pre>
<p><img src="/.com//output_34_1.png"></p>
<h3 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h3><p>一个int类型的方针，大小根据需求定。一般来说卷积核越小处理得越细致，但需要的算力也就越大。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义卷积核</span></span><br><span class="line">kernel1 = np.ones((<span class="number">30</span>,<span class="number">30</span>),np.uint8)</span><br><span class="line">kernel2 = np.ones((<span class="number">20</span>,<span class="number">20</span>),np.uint8)</span><br><span class="line">kernel3 = np.ones((<span class="number">10</span>,<span class="number">10</span>),np.uint8)</span><br></pre></td></tr></table></figure>

<h4 id="形态学腐蚀"><a href="#形态学腐蚀" class="headerlink" title="形态学腐蚀"></a>形态学腐蚀</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">erosion1 = cv2.erode(img21,kernel1,iterations = <span class="number">2</span>)</span><br><span class="line">erosion2 = cv2.erode(img21,kernel2,iterations = <span class="number">2</span>)</span><br><span class="line">erosion3 = cv2.erode(img21,kernel3,iterations = <span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(erosion1,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=30&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(erosion2,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=20&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(erosion3,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=10&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;kernel=10&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b9b3ab20&gt;,
 Text(0.5, 1.0, &#39;kernel=10&#39;))
</code></pre>
<p><img src="/.com//output_38_1.png"></p>
<h4 id="形态学膨胀"><a href="#形态学膨胀" class="headerlink" title="形态学膨胀"></a>形态学膨胀</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dilate1 = cv2.dilate(img21,kernel1,iterations = <span class="number">2</span>)</span><br><span class="line">dilate2 = cv2.dilate(img21,kernel2,iterations = <span class="number">2</span>)</span><br><span class="line">dilate3 = cv2.dilate(img21,kernel3,iterations = <span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(dilate1,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=30&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(dilate2,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=20&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(dilate3,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=10&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;kernel=10&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b9c1e730&gt;,
 Text(0.5, 1.0, &#39;kernel=10&#39;))
</code></pre>
<p><img src="/.com//output_40_1.png"></p>
<h4 id="腐蚀和膨胀是互逆的操作"><a href="#腐蚀和膨胀是互逆的操作" class="headerlink" title="腐蚀和膨胀是互逆的操作"></a>腐蚀和膨胀是互逆的操作</h4><p>下面的操作可以证明这一点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dilate1 = cv2.dilate(erosion1,kernel1,iterations = <span class="number">2</span>)</span><br><span class="line">dilate2 = cv2.dilate(erosion2,kernel2,iterations = <span class="number">2</span>)</span><br><span class="line">dilate3 = cv2.dilate(erosion3,kernel3,iterations = <span class="number">2</span>)</span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(dilate1,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=30&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(dilate2,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=20&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(dilate3,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;kernel=10&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;kernel=10&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3bae60250&gt;,
 Text(0.5, 1.0, &#39;kernel=10&#39;))
</code></pre>
<p><img src="/.com//output_42_1.png"></p>
<h3 id="开运算和闭运算"><a href="#开运算和闭运算" class="headerlink" title="开运算和闭运算"></a>开运算和闭运算</h3><p><strong>开运算：先腐蚀，后膨胀</strong><br><strong>闭运算：先膨胀，后腐蚀</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line"></span><br><span class="line">opening = cv2.morphologyEx(img21,cv2.MORPH_OPEN,kernel)</span><br><span class="line">closing = cv2.morphologyEx(img21,cv2.MORPH_CLOSE,kernel)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(opening,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;Open&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(closing,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;Close&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;Close&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3baf06700&gt;,
 Text(0.5, 1.0, &#39;Close&#39;))
</code></pre>
<p><img src="/.com//output_44_1.png"></p>
<h3 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h3><p>梯度&#x3D;膨胀-腐蚀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img22 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\Apple-Symbol.png&quot;</span>)</span><br><span class="line"><span class="comment">#cv2内置梯度运算</span></span><br><span class="line">gradient = cv2.morphologyEx(img22,cv2.MORPH_GRADIENT,kernel)</span><br><span class="line"><span class="comment">#膨胀-腐蚀</span></span><br><span class="line">dilate22 = cv2.dilate(img22,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">erosion22 = cv2.erode(img22,kernel,iterations = <span class="number">1</span>)</span><br><span class="line">result22 = dilate22-erosion22</span><br><span class="line"><span class="comment">#显示图像</span></span><br><span class="line">plt.subplot(<span class="number">221</span>),plt.imshow(img22,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;orignal&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>),plt.imshow(gradient,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;gradient&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>),plt.imshow(result22,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;dilate-erosion&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;dilate-erosion&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3bafd9550&gt;,
 Text(0.5, 1.0, &#39;dilate-erosion&#39;))
</code></pre>
<p><img src="/.com//output_46_1.png"></p>
<h3 id="礼帽和黑帽"><a href="#礼帽和黑帽" class="headerlink" title="礼帽和黑帽"></a>礼帽和黑帽</h3><ul>
<li>礼帽：原始输入-开运算结果  </li>
<li>黑帽：闭运算-原始输入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img23 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\maoci.jpg&quot;</span>)</span><br><span class="line">tophat = cv2.morphologyEx(img23,cv2.MORPH_TOPHAT,kernel)</span><br><span class="line">blackhat = cv2.morphologyEx(img23,cv2.MORPH_BLACKHAT,kernel)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(tophat,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;TOPHAT&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blackhat,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;BLACKHAT&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;BLACKHAT&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b9b7f940&gt;,
 Text(0.5, 1.0, &#39;BLACKHAT&#39;))
</code></pre>
<p><img src="/.com//output_48_1.png"></p>
<h3 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h3><h4 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h4><p>$G_x &#x3D;<br>\begin{bmatrix}<br>-1&amp;0&amp;+1\<br>-2&amp;0&amp;+2\<br>-1&amp;0&amp;+1\<br>\end{bmatrix}<br>*A<br>$<br> and<br>$G_y &#x3D;<br>\begin{bmatrix}<br>-1&amp;-2&amp;-1\<br>0&amp;0&amp;0\<br>+1&amp;+2&amp;+1\<br>\end{bmatrix}<br>*A<br>$</p>
<p><strong>dst&#x3D;cv2.Sobel(src,ddepth,dx,dy,ksize)</strong></p>
<ul>
<li>ddepth:图像深度  </li>
<li>dx、dy分别表示水平和竖直方向  </li>
<li>ksize是Sobel算子的大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img31 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\lunkuo.png&quot;</span>)</span><br><span class="line">sobelx = cv2.Sobel(img31,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize = <span class="number">1</span>)</span><br><span class="line">sobely = cv2.Sobel(img31,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(img31,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(sobelx,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(sobely,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).
Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).





(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3b4c9fa30&gt;)
</code></pre>
<p><img src="/.com//output_52_2.png"></p>
<p>白色到黑色是正数，黑色到白色是负数，负数会被截断成0，因此要取绝对值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#取绝对值操作</span></span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(sobelx,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(sobely,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3b422b0d0&gt;)
</code></pre>
<p><img src="/.com//output_54_1.png" alt="png"></p>
<p><strong>求和操作</strong><br>对比分开计算求和的结果和直接计算，明显看出分开计算求和的效果好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#分开计算求和</span></span><br><span class="line">sobelxy = cv2.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#直接计算</span></span><br><span class="line">sobelx_y = cv2.Sobel(img31,cv2.CV_64F,<span class="number">1</span>,<span class="number">1</span>,ksize=<span class="number">1</span>)</span><br><span class="line">sobelx_y = cv2.convertScaleAbs(sobelx_y)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(sobelxy,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;Calculate the sum separately&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(sobelx_y,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;Direct calculations&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;Direct calculations&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b42c9490&gt;,
 Text(0.5, 1.0, &#39;Direct calculations&#39;))
</code></pre>
<p><img src="/.com//output_56_1.png"></p>
<h4 id="Scharr算子"><a href="#Scharr算子" class="headerlink" title="Scharr算子"></a>Scharr算子</h4><p>$$<br>G_x &#x3D;<br>\begin{bmatrix}<br>-3&amp;0&amp;3\<br>-10&amp;0&amp;10\<br>-3&amp;0&amp;3\<br>\end{bmatrix}<br>*A<br>$<br> and<br>$G_y &#x3D;<br>\begin{bmatrix}<br>3&amp;10&amp;3\<br>0&amp;0&amp;0\<br>-3&amp;-10&amp;13\<br>\end{bmatrix}<br>*A<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scharrx = cv2.Scharr(img31,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">scharry = cv2.Scharr(img31,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)</span><br><span class="line">scharry = cv2.convertScaleAbs(scharry)</span><br><span class="line"></span><br><span class="line">scharrxy = cv2.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line">plt.imshow(scharrxy,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b432fa90&gt;
</code></pre>
<p><img src="/.com//output_58_1.png"></p>
<h4 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h4><p>$<br>G &#x3D;<br>\begin{bmatrix}<br>0&amp;1&amp;0\<br>1&amp;-4&amp;1\<br>0&amp;1&amp;0\<br>\end{bmatrix}<br>$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(img31,cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br><span class="line">plt.imshow(laplacian,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b4389250&gt;
</code></pre>
<p><img src="/.com//output_60_1.png"></p>
<h4 id="三种算子的对比"><a href="#三种算子的对比" class="headerlink" title="三种算子的对比"></a>三种算子的对比</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">img32 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\gril0.jpg&quot;</span>)</span><br><span class="line">sobelx = cv2.Sobel(img32,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize = <span class="number">1</span>)</span><br><span class="line">sobely = cv2.Sobel(img32,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize = <span class="number">1</span>)</span><br><span class="line">scharrx = cv2.Scharr(img32,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">scharry = cv2.Scharr(img32,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">laplacian = cv2.Laplacian(img32,cv2.CV_64F)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)</span><br><span class="line">scharry = cv2.convertScaleAbs(scharry)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line">sobelxy = cv2.addWeighted(sobelx,<span class="number">0.5</span>,sobely,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">scharrxy = cv2.addWeighted(scharrx,<span class="number">0.5</span>,scharry,<span class="number">0.5</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">141</span>),plt.imshow(img32,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;orignal&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">142</span>),plt.imshow(sobelxy,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;sobel&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">143</span>),plt.imshow(scharrxy,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;scharr&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">144</span>),plt.imshow(laplacian,<span class="string">&quot;gray&quot;</span>),plt.title(<span class="string">&quot;laplacian&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:title=&#123;&#39;center&#39;:&#39;laplacian&#39;&#125;&gt;,
 &lt;matplotlib.image.AxesImage at 0x1f3b4ba6460&gt;,
 Text(0.5, 1.0, &#39;laplacian&#39;))
</code></pre>
<p>​<br><img src="/.com//output_62_1.png" alt="png"><br>​    </p>
<h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><ul>
<li>1）使用高斯滤波器，过滤噪声  </li>
<li>2）计算图像中像素点的梯度强度和方向  </li>
<li>3）应用非极大值抑制，以消除边缘检测带来的杂散响应  </li>
<li>4）应用双阈值检测来确定真实的和潜在的边缘  </li>
<li>5）通过抑制孤立的弱边最终完成边缘检测  <h4 id="1-高斯滤波器"><a href="#1-高斯滤波器" class="headerlink" title="1.高斯滤波器"></a>1.高斯滤波器</h4>$<br>e &#x3D; H*A&#x3D;<br>\begin{bmatrix}<br>h_{11}&amp;h_{12}&amp;h_{13}\<br>h_{21}&amp;h_{22}&amp;h_{23}\<br>h_{31}&amp;h_{32}&amp;h_{33}\<br>\end{bmatrix}</li>
<li>\begin{bmatrix}<br>a&amp;b&amp;c\<br>d&amp;e&amp;f\<br>g&amp;h&amp;i\<br>\end{bmatrix}<br>&#x3D;sum<br>\begin{pmatrix}<br>\begin{bmatrix}<br>a\times h_{11}&amp;b\times h_{12}&amp;c\times h_{13}\<br>d\times h_{21}&amp;e\times h_{22}&amp;f\times h_{23}\<br>g\times h_{31}&amp;h\times h_{32}&amp;i\times h_{33}\<br>\end{bmatrix}<br>\end{pmatrix}<br>$  <h4 id="2-梯度和方向"><a href="#2-梯度和方向" class="headerlink" title="2.梯度和方向"></a>2.梯度和方向</h4>$S_x&#x3D;\begin{bmatrix}</li>
</ul>
<p>-1&amp;0&amp;1\<br>-2&amp;0&amp;2\<br>-1&amp;0&amp;1\<br>\end{bmatrix}<br>$<br>$\qquad$<br>$<br>S_x&#x3D;<br>\begin{bmatrix}<br>1&amp;2&amp;1\<br>0&amp;0&amp;0\<br>-1&amp;-1&amp;11\<br>\end{bmatrix}<br>$<br>$<br>G_x &#x3D; S_x<em>A&#x3D;<br>\begin{bmatrix}<br>-1&amp;0&amp;1\<br>-2&amp;0&amp;2\<br>-1&amp;0&amp;1\<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>a&amp;b&amp;c\<br>d&amp;e&amp;f\<br>g&amp;h&amp;i\<br>\end{bmatrix}<br>&#x3D;sum\begin{pmatrix}<br>\begin{bmatrix}<br>-a&amp;0&amp;c\<br>-2d&amp;0&amp;2f\<br>-g&amp;0&amp;i\<br>\end{bmatrix}<br>\end{pmatrix}<br>$<br>$<br>G_y &#x3D; S_x</em>A&#x3D;<br>\begin{bmatrix}<br>1&amp;2&amp;1\<br>0&amp;0&amp;o\<br>-1&amp;-2&amp;-1\<br>\end{bmatrix}<br>*<br>\begin{bmatrix}<br>a&amp;b&amp;c\<br>d&amp;e&amp;f\<br>g&amp;h&amp;i\<br>\end{bmatrix}<br>&#x3D;sum\begin{pmatrix}<br>\begin{bmatrix}<br>a&amp;b&amp;c\<br>0&amp;0&amp;0\<br>-g&amp;-2h&amp;-i\<br>\end{bmatrix}<br>\end{pmatrix}<br>$<br>$G&#x3D;\sqrt{G{^2_x}+G{^2_y}}$<br>$\qquad$<br>$\qquad {\theta}&#x3D;arctan(G_y&#x2F;G_x)$</p>
<h4 id="3-非极大值抑制（Non-Maximum-Suppression（NMS））"><a href="#3-非极大值抑制（Non-Maximum-Suppression（NMS））" class="headerlink" title="3.非极大值抑制（Non-Maximum Suppression（NMS））"></a>3.非极大值抑制（Non-Maximum Suppression（NMS））</h4><blockquote>
<p>NMS的基本思想是将所有框按得分进行排序，然后无条件保留其中得分最高的框，然后遍历其余框找到和当前最高分的框的重叠面积（IOU）大于一定阈值的框，并删除。然后继续这个过程，找另一个得分高的框，再删除和其IOU大于阈值的框，一直循环直到所有的框都被处理。<br>在目标检测中，常用非极大值抑制算法(NMS)对生成的大量候选框进行后处理，在 faster R-CNN 中，每一个 bbox 都有一个得分，然后使用 NMS 去除冗余的候选框，得到最具代表性的 bbox，以加快目标检测的效率。<br><img src="/.com//attachment:image.png" alt="image.png"><br> <strong>NMS的具体实现流程为：</strong><br>Ⅰ.根据候选框的类别分类概率（得分），按最高到最低将BBox排序，例如：A&gt;B&gt;C&gt;D&gt;E&gt;F<br>Ⅱ.先标记最大概率矩形框A是要保留下来的，即A的分数最高，则无条件保留<br>Ⅲ.将B~E分别与A求重叠率IoU（两框的交并比），假设B、D与A的IoU大于设定的阈值，那么B和D可以认为是重复标记被剔除<br>Ⅳ.继续从剩下的矩形框C、E、F中选择概率最大的C，标记为要无条件保留下来的框，然后分别计算C与E、F的重叠度，扔掉重叠度超过设定阈值的矩形框<br>Ⅴ.就这样一直重复下去，直到剩下的矩形框没有了，得到所有要保留下来的矩形框.  </p>
</blockquote>
<pre><code>线性插值法：  
设G1的梯度幅值为M（G1），G2的梯度幅值为M（G2），则dtmp1可以得到  
&lt;center&gt;$M(dtmp1)=w\times M(G2)+(1-w)\times M(G1)$&lt;/center&gt;  
其中$w=\frac&#123;distance(dtmp1,G2)&#125;&#123;distance(G1,G2)&#125;$  
</code></pre>
<p><img src="/.com//attachment:image-2.png" alt="image-2.png"></p>
<pre><code>为了简化计算，由于一个像素周围只有八个像素，把一个像素的梯度和方向离散为八个方向，这样就只需要计算前后即可，不需要插值计算。
</code></pre>
<h4 id="双阈值检测"><a href="#双阈值检测" class="headerlink" title="双阈值检测"></a>双阈值检测</h4><p><img src="/.com//attachment:image-3.png" alt="image-3.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img41 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\wallhaven-p2j1w9.jpg&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">v1 = cv2.Canny(img41,<span class="number">50</span>,<span class="number">120</span>)</span><br><span class="line">v2 = cv2.Canny(img41,<span class="number">120</span>,<span class="number">150</span>)</span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(img41,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(v1,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(v2,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3b4d51b50&gt;)
</code></pre>
<p>​<br><img src="/.com//output_64_1.png" alt="png"><br>​    </p>
<h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><h4 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h2><h3 id="轮廓检索"><a href="#轮廓检索" class="headerlink" title="轮廓检索"></a>轮廓检索</h3><p><strong>cv2.findContour(img,mode,method)</strong><br>mode:轮廓检索模式  </p>
<ul>
<li>RETR_EXTERNAL:只检测最外边轮廓  </li>
<li>RETR_LIST:检测所有的轮廓，并将其保留到一个链表中  </li>
<li>RETR_CCMOR:检测所有的轮廓，并将它们分为两层，顶层是各部分的外部边界，第二层是空洞的边界  </li>
<li>RETR_TREE（常用）:检索左右的轮廓，并重构嵌套轮廓的整个层次</li>
</ul>
<p>method:轮廓逼近方法  </p>
<ul>
<li>CHAIN_APPROX_NONE:以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）</li>
<li>CHAIN_APPROX_SIMPLE：压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分</li>
</ul>
<h3 id="轮廓绘制"><a href="#轮廓绘制" class="headerlink" title="轮廓绘制"></a>轮廓绘制</h3><p>步骤：  </p>
<ol>
<li>导入图像  </li>
<li>转化为灰度图  </li>
<li>二值化图像  </li>
<li>轮廓检索</li>
<li>在原图像上绘制轮廓</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img51 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\gril1.png&quot;</span>)</span><br><span class="line">img51_gray = cv2.cvtColor(img51,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh = cv2.threshold(img51_gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE)</span><br><span class="line"><span class="comment">#绘制轮廓</span></span><br><span class="line">draw_img = img51.copy()<span class="comment">#在原图像上去画，所以要对原图像进行copy,如果不用copy的话原图也会跟着变</span></span><br><span class="line">res = cv2.drawContours(draw_img,contours,-<span class="number">1</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)<span class="comment">#绘制轮廓的函数</span></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(res,<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(img51,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3b4e00cd0&gt;)
</code></pre>
<p>​<br><img src="/.com//output_70_1.png" alt="png"><br>​    </p>
<h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#面积特征</span></span><br><span class="line">cv2.contourArea(cnt)</span><br></pre></td></tr></table></figure>




<pre><code>106.5
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#周长特征</span></span><br><span class="line">cv2.arcLength(cnt,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<pre><code>65.21320307254791
</code></pre>
<h3 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img52 = cv2.imread(<span class="string">&quot;D:\programing\Python\CV\cola.png&quot;</span>)</span><br><span class="line">img52_gray = cv2.cvtColor(img52,cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret,thresh = cv2.threshold(img52_gray,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[<span class="number">5</span>]</span><br><span class="line">epsilon = <span class="number">0.01</span>*cv2.arcLength(cnt,<span class="literal">True</span>)</span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">draw_img = img52.copy()</span><br><span class="line">res = cv2.drawContours(draw_img,[approx],-<span class="number">1</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.imshow(res,<span class="string">&quot;gray&quot;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b4cdd760&gt;
</code></pre>
<p>​<br><img src="/.com//output_75_1.png" alt="png"><br>​    </p>
<h3 id="外接图形"><a href="#外接图形" class="headerlink" title="外接图形"></a>外接图形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#外界矩形操作</span></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">img53 = cv2.rectangle(img52,(x,y),(x+w,y+h),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">plt.imshow(img53)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;matplotlib.image.AxesImage at 0x1f3b4bf7280&gt;
</code></pre>
<p>​<br><img src="/.com//output_77_1.png" alt="png"><br>​    </p>
<h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p>原理与卷积类似，模板在原图像上滑动，计算模板与原图片上相应区域的差别程度，将计算结果放入一个矩阵里，作为输出的结果。<br>假设原图像是A$\times $B,模板为a$\times $b，则输出的矩阵为$(A-a+1)\times (B-b+1)$。<br>差别度计算方法：  </p>
<ul>
<li>TM_SQDIFF：计算平方不同，计算出来的值越小，越相关  </li>
<li>TM_CCORR：计算相关性，计算出来的值越大，越相关  </li>
<li>TM_CCOEFF；计算相关系数，计算出来的值越大，越相关  </li>
<li>TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关  </li>
<li>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关  </li>
<li>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template = cv2.imread(<span class="string">&#x27;images\colors02.png&#x27;</span>)</span><br><span class="line">methods = [<span class="string">&#x27;cv2.TM_SQDIFF&#x27;</span>,<span class="string">&#x27;cv2.TM_CCORR&#x27;</span>,<span class="string">&#x27;cv2.TM_CCOEFF&#x27;</span>,<span class="string">&#x27;cv2.TM_SQDIFF_NORMED&#x27;</span>,<span class="string">&#x27;cv2.TM_CCORR_NORMED&#x27;</span>,<span class="string">&#x27;cv2.TM_CCOEFF_NORMED&#x27;</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> method <span class="keyword">in</span> methods:</span><br><span class="line">    img = img1.copy()</span><br><span class="line">    method0 = <span class="built_in">eval</span>(method)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#模板匹配</span></span><br><span class="line">    res = cv2.matchTemplate(img1,template,method0)</span><br><span class="line">    min_val,max_val,min_loc,max_loc = cv2.minMaxLoc(res)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> method <span class="keyword">in</span> [cv2.TM_SQDIFF,cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">        top_left = min_loc</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top_left = max_loc</span><br><span class="line">    bottom_right = (top_left[<span class="number">0</span>] + w,top_left[<span class="number">1</span>]+h)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#画矩形</span></span><br><span class="line">    cv2.rectangle(img,top_left,bottom_right,<span class="number">255</span>,<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    plt.subplot(<span class="number">121</span>),plt.imshow(res,cmap = <span class="string">&#x27;gray&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>),plt.imshow(img,cmap = <span class="string">&#x27;gray&#x27;</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">    plt.suptitle(method)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/.com//output_80_0.png" alt="png"><br>​    </p>
<p><img src="/.com//output_80_1.png" alt="png"></p>
<p><img src="/.com//output_80_2.png" alt="png"></p>
<p><img src="/.com//output_80_3.png" alt="png"></p>
<p><img src="/.com//output_80_4.png" alt="png"></p>
<p><img src="/.com//output_80_5.png" alt="png"></p>
<h2 id="图形统计学特征"><a href="#图形统计学特征" class="headerlink" title="图形统计学特征"></a>图形统计学特征</h2><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p><img src="/.com//attachment:image.png" alt="image.png"><br><strong>cv2.calcHist(img,channel,mask,histSize,ranges)</strong><br>img:不多BB<br>channel:定义图像的色彩通道，灰度图像是[0],B、G、R分别对应[1],[2],[3]<br>mask:图像掩膜，类似于PS里的蒙版<br>histSize:BIN的数目<br>ranges:像素值范围常为[0256]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">colors = (<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i,color <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors):</span><br><span class="line">    hist = cv2.calcHist([img51],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.subplot(<span class="number">122</span>),plt.plot(hist,color = color,)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img51)</span><br></pre></td></tr></table></figure>

<pre><code>&lt;ipython-input-71-0558f478d2b1&gt;:4: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
  plt.subplot(122),plt.plot(hist,color = color,)
&lt;ipython-input-71-0558f478d2b1&gt;:4: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
  plt.subplot(122),plt.plot(hist,color = color,)





(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3c63d25e0&gt;)
</code></pre>
<p>​<br><img src="/.com//output_82_2.png" alt="png"><br>​    </p>
<p>当定义mask时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img61 = cv2.imread(<span class="string">&#x27;images/stars.jpg&#x27;</span>)</span><br><span class="line">mask = np.zeros(img61.shape[:<span class="number">2</span>],np.uint8)</span><br><span class="line"><span class="built_in">print</span>(mask.shape)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">600</span>,<span class="number">100</span>:<span class="number">1100</span>] = <span class="number">255</span></span><br></pre></td></tr></table></figure>

<pre><code>(792, 1200)
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mask_img61 = cv2.bitwise_and(img61,img61,mask = mask)</span><br><span class="line">colors = (<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i,color <span class="keyword">in</span> <span class="built_in">enumerate</span>(colors):</span><br><span class="line">    hist = cv2.calcHist([img61],[i],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.subplot(<span class="number">224</span>),plt.plot(hist,color = color)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.subplot(<span class="number">221</span>),plt.imshow(img61)</span><br><span class="line">plt.subplot(<span class="number">222</span>),plt.imshow(mask)</span><br><span class="line">plt.subplot(<span class="number">223</span>),plt.imshow(mask_img61)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>&lt;ipython-input-90-85332e640577&gt;:5: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
  plt.subplot(224),plt.plot(hist,color = color)
&lt;ipython-input-90-85332e640577&gt;:5: MatplotlibDeprecationWarning: Adding an axes using the same arguments as a previous axes currently reuses the earlier instance.  In a future version, a new instance will always be created and returned.  Meanwhile, this warning can be suppressed, and the future behavior ensured, by passing a unique label to each axes instance.
  plt.subplot(224),plt.plot(hist,color = color)





(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3db8d4dc0&gt;)
</code></pre>
<p>​<br><img src="/.com//output_85_2.png" alt="png"><br>​    </p>
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img61_gray = cv2.cvtColor(img61,cv2.COLOR_BGR2GRAY)</span><br><span class="line">equ = cv2.equalizeHist(img61_gray)</span><br><span class="line">plt.subplot(<span class="number">221</span>),plt.imshow(img61_gray,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>),plt.imshow(equ,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>),plt.hist(img61_gray.ravel(),<span class="number">256</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>),plt.hist(equ.ravel(),<span class="number">256</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p>​<br><img src="/.com//output_87_0.png" alt="png"><br>​    </p>
<h3 id="自适应直方图均衡化"><a href="#自适应直方图均衡化" class="headerlink" title="自适应直方图均衡化"></a>自适应直方图均衡化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clache = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>,tileGridSize = (<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">res_clahe=clache.apply(img61_gray)</span><br><span class="line">plt.subplot(<span class="number">131</span>),plt.imshow(img61_gray,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">132</span>),plt.imshow(equ,<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">133</span>),plt.imshow(res_clahe,<span class="string">&#x27;gray&#x27;</span>)</span><br></pre></td></tr></table></figure>




<pre><code>(&lt;AxesSubplot:&gt;, &lt;matplotlib.image.AxesImage at 0x1f3dbbdc9a0&gt;)
</code></pre>
<p>​<br><img src="/.com//output_89_1.png" alt="png"><br>​    </p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p><img src="/.com//attachment:image.png" alt="image.png"></p>
<h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><h4 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h4><p>只保留低频，使图像模糊  </p>
<h4 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h4><p>只保留高频，使图像细节增强</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2022-03-18T13:14:39.657Z" itemprop="datePublished">
              2022-03-18
            </time>
          </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2022 - Alcatraz </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>